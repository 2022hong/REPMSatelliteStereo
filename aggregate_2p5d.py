import numpy as npimport osfrom aggregate_2p5d_util import convert_depth_mapsfrom lib.ply_np_converter import np2plyimport jsonfrom lib.dsm_util import read_dsm_tif,  similar_shpfrom produce_dsm import height_fliter, produce_dsm_from_heightimport cv2import imageiofrom osgeo import gdal,gdalconst,osrdef run_fuse(mvs_dir, out_dir, DSM_param, enu_origin, imgtype='3-view',  aoi_path=None):    if imgtype != 'multi-data':        aoi_dict = None        # first convert depth maps        convert_depth_maps(mvs_dir, out_dir, DSM_param, enu_origin, depth_type='geometric',aoi_dict=aoi_dict)        height_fliter(out_dir, DSM_param)        dsms, dsm1, dsm2, dsm3  = [], [], [], []        dsm_tif_dir = os.path.join(out_dir, 'dsm_fliter')        dsm_names = sorted(os.listdir(dsm_tif_dir))        for dsm_name in dsm_names:            if dsm_name[:4]=='0000':                tif_dir = os.path.join(dsm_tif_dir,dsm_name)                dsm1.append(tif_dir)            elif dsm_name[:4]=='0001':                tif_dir = os.path.join(dsm_tif_dir,dsm_name)                dsm2.append(tif_dir)            else:                tif_dir = os.path.join(dsm_tif_dir,dsm_name)                dsm3.append(tif_dir)        dsms.append(dsm1)        dsms.append(dsm2)        if len(dsm3) != 0:            dsms.append(dsm3)        # Mosaic. Splicing blocks of images from the same perspective        resampleAlg = 1        for n in range(len(dsms)):            gdal.AllRegister()            osrs = []            tifs = dsms[n]            for tif in tifs:                ds = gdal.Open(tif, gdalconst.GA_ReadOnly)                osr_ = gdal.Dataset.GetSpatialRef(ds)                osrs.append(osr_)            osr_ = osrs[0]            for osri in osrs:                flag = osr.SpatialReference.IsSame(osr_, osri)                if not(flag):                    print('待拼接的栅格影像必须有相同的空间参考！')                    exit(0)            if resampleAlg == 0:                resampleType = gdalconst.GRA_NearestNeighbour            elif resampleAlg == 1:                resampleType = gdalconst.GRA_Bilinear            else:                resampleType = gdalconst.GRA_Cubic            options = gdal.WarpOptions(                srcSRS=osr_, dstSRS=osr_, format='GTiff', resampleAlg=resampleType, creationOptions=["COMPRESS=LZW"])            os.makedirs(os.path.join(out_dir, 'dsm_joint'), exist_ok=True)            destFile = os.path.join(out_dir, 'dsm_joint', 'dsm_{}.tif'.format(n))            gdal.Warp(destFile, tifs, options=options)        dsm_path = os.path.join(out_dir, 'dsm_joint')        all_dsm, min_X, max_Y = similar_shp(dsm_path)        num_threshold = 1    else:        num_threshold = 2        if aoi_path != None:            with open(os.path.join(mvs_dir, 'aoi.json')) as fp:                aoi_dict = json.load(fp)            # first convert depth maps            convert_depth_maps(mvs_dir, out_dir, DSM_param, enu_origin, depth_type='geometric', aoi_dict=aoi_dict)            height_fliter(out_dir, DSM_param)            dsm_path = os.path.join(out_dir, 'dsm_fliter')            all_dsm = []            for item in sorted(os.listdir(dsm_path)):                dsm, _ = read_dsm_tif(os.path.join(dsm_path, item))                all_dsm.append(dsm[:, :, np.newaxis])            min_X, max_Y = aoi_dict['ul_easting'], aoi_dict['ul_northing']        else:            aoi_dict = None            # first convert depth maps            convert_depth_maps(mvs_dir, out_dir, DSM_param, enu_origin, depth_type='geometric',                                aoi_dict=aoi_dict)            height_fliter(out_dir, DSM_param)            dsm_path = os.path.join(out_dir, 'dsm_fliter')            all_dsm, min_X, max_Y = similar_shp(dsm_path)    cnt = len(all_dsm)    all_dsm = np.concatenate(all_dsm, axis=2)    # reject two measurements    num_measurements = cnt - np.sum(np.isnan(all_dsm), axis=2, keepdims=True)    mask = np.tile(num_measurements < num_threshold, (1, 1, cnt))    all_dsm[mask] = np.nan    print(num_threshold)    # reject outliers based on MAD statistics    all_dsm_median = np.nanmedian(all_dsm, axis=2, keepdims=True)    all_dsm_mad = np.nanmedian(np.abs(all_dsm - all_dsm_median), axis=2, keepdims=True)    outlier_mask = np.abs(all_dsm - all_dsm_median) > all_dsm_mad    all_dsm[outlier_mask] = np.nan    all_dsm_mean_no_outliers = np.nanmean(all_dsm, axis=2)    # median filter    all_dsm_mean_no_outliers = cv2.medianBlur(all_dsm_mean_no_outliers.astype(np.float32), 3)    # print(all_dsm_mean_no_outliers)    # print(all_dsm_mean_no_outliers.shape)    # write tif    if not os.path.exists(os.path.join(out_dir, 'aggregate_2p5d')):        os.mkdir(os.path.join(out_dir, 'aggregate_2p5d'))    tif_to_write = os.path.join(out_dir, 'aggregate_2p5d', 'aggregate_2p5d_dsm.tif')    jpg_to_write = os.path.join(out_dir, 'aggregate_2p5d',  'aggregate_2p5d_dsm.jpg')    ul_e, ul_n, e_size, n_size, e_resolution, n_resolution = produce_dsm_from_height( all_dsm_mean_no_outliers,                                                         DSM_param,min_X, max_Y, tif_to_write, jpg_to_write)    void_ratio = np.sum(np.isnan(all_dsm_mean_no_outliers)) / all_dsm_mean_no_outliers.size    print('\n After aggregation, empty ratio: {} '.format(void_ratio))    # create a colored point cloud    xx = ul_n - np.arange(n_size) * n_resolution    yy = ul_e + np.arange(e_size) * e_resolution    xx, yy = np.meshgrid(xx, yy, indexing='ij')     # xx, yy are of shape (height, width)    xx = xx.reshape((-1, 1))    yy = yy.reshape((-1, 1))    zz = all_dsm_mean_no_outliers.reshape((-1, 1))    color = imageio.v2.imread(jpg_to_write).reshape((-1, 3))    valid_mask = np.logical_not(np.isnan(zz)).flatten()    xx = xx[valid_mask, :]    yy = yy[valid_mask, :]    zz = zz[valid_mask, :]    color = color[valid_mask, :]    points = np.concatenate((yy, xx, zz), axis=1)    comment_1 = 'projection: UTM {}{}'.format(DSM_param[0], DSM_param[1])    comments = [comment_1,]    np2ply(points, os.path.join(out_dir, 'aggregate_2p5d', 'aggregate_2p5d.ply'),            color=color, comments=comments, use_double=True)if __name__ == '__main__':    pass